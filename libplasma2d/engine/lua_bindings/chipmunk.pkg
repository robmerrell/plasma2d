$#include "chipmunk.h"
$#include <stdint.h>
$#include <math.h>

module chipmunk {
    // chipmunk_types.h
    typedef float cpFloat;
    #define INFINITY (__builtin_inf())
    typedef struct cpVect{cpFloat x,y;} cpVect;
    // #define cpfsqrt sqrtf;
    // #define cpfsin sinf;
    // #define cpfcos cosf;
    // #define cpfacos acosf;
    // #define cpfatan2 atan2f;
    // #define cpfmod fmodf;
    // #define cpfexp expf;
    // #define cpfpow powf;
    // #define cpffloor floorf;
    // #define cpfceil ceilf;
    
    // cpVect.h
    static const cpVect cpvzero;
    static inline cpVect cpv(const cpFloat x, const cpFloat y);
    cpFloat cpvlength(const cpVect v);
    cpVect cpvslerp(const cpVect v1, const cpVect v2, const cpFloat t);
    cpVect cpvslerpconst(const cpVect v1, const cpVect v2, const cpFloat a);
    cpVect cpvforangle(const cpFloat a);
    cpFloat cpvtoangle(const cpVect v);
    static inline cpBool cpveql(const cpVect v1, const cpVect v2);
    static inline cpVect cpvadd(const cpVect v1, const cpVect v2);
    static inline cpVect cpvsub(const cpVect v1, const cpVect v2);
    static inline cpVect cpvneg(const cpVect v);
    static inline cpVect cpvmult(const cpVect v, const cpFloat s);
    static inline cpFloat cpvdot(const cpVect v1, const cpVect v2);
    static inline cpFloat cpvcross(const cpVect v1, const cpVect v2);
    static inline cpVect cpvperp(const cpVect v);
    static inline cpVect cpvrperp(const cpVect v);
    static inline cpVect cpvproject(const cpVect v1, const cpVect v2);
    static inline cpVect cpvrotate(const cpVect v1, const cpVect v2);
    static inline cpVect cpvunrotate(const cpVect v1, const cpVect v2);
    static inline cpFloat cpvlengthsq(const cpVect v);
    static inline cpVect cpvlerp(const cpVect v1, const cpVect v2, const cpFloat t);
    static inline cpVect cpvnormalize(const cpVect v);
    static inline cpVect cpvnormalize_safe(const cpVect v);
    static inline cpVect cpvclamp(const cpVect v, const cpFloat len);
    static inline cpVect cpvlerpconst(cpVect v1, cpVect v2, cpFloat d);
    static inline cpFloat cpvdist(const cpVect v1, const cpVect v2);
    static inline cpFloat cpvdistsq(const cpVect v1, const cpVect v2);
    static inline cpBool cpvnear(const cpVect v1, const cpVect v2, const cpFloat dist);
    
    // chipmunk.h
    cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset);
    cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);
    cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b);
    cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat r);
    cpFloat cpMomentForPoly(cpFloat m, int numVerts, const cpVect *verts, cpVect offset);
    cpFloat cpAreaForPoly(const int numVerts, const cpVect *verts);
    cpVect cpCentroidForPoly(const int numVerts, const cpVect *verts);
    void cpRecenterPoly(const int numVerts, cpVect *verts);
    cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);
    cpFloat cpMomentForBox2(cpFloat m, cpBB box);
    
    // cpSpace.h
    struct cpSpace {
    	int iterations;
    	cpVect gravity;
    	cpFloat damping;
    	cpFloat idleSpeedThreshold;
    	cpFloat sleepTimeThreshold;
    	cpFloat collisionSlop;
    	cpFloat collisionBias;
    	cpTimestamp collisionPersistence;
    	cpBool enableContactGraph;
    	cpDataPointer data;
    	cpBody *staticBody;
    };
    void cpSpaceSetDefaultCollisionHandler(
    	cpSpace *space,
    	cpCollisionBeginFunc begin,
    	cpCollisionPreSolveFunc preSolve,
    	cpCollisionPostSolveFunc postSolve,
    	cpCollisionSeparateFunc separate,
    	void *data
    );
    void cpSpaceAddCollisionHandler(
    	cpSpace *space,
    	cpCollisionType a, cpCollisionType b,
    	cpCollisionBeginFunc begin,
    	cpCollisionPreSolveFunc preSolve,
    	cpCollisionPostSolveFunc postSolve,
    	cpCollisionSeparateFunc separate,
    	void *data
    );
    void cpSpaceRemoveCollisionHandler(cpSpace *space, cpCollisionType a, cpCollisionType b);
    cpShape *cpSpaceAddShape(cpSpace *space, cpShape *shape);
    cpShape *cpSpaceAddStaticShape(cpSpace *space, cpShape *shape);
    cpBody *cpSpaceAddBody(cpSpace *space, cpBody *body);
    cpConstraint *cpSpaceAddConstraint(cpSpace *space, cpConstraint *constraint);
    void cpSpaceRemoveShape(cpSpace *space, cpShape *shape);
    void cpSpaceRemoveStaticShape(cpSpace *space, cpShape *shape);
    void cpSpaceRemoveBody(cpSpace *space, cpBody *body);
    void cpSpaceRemoveConstraint(cpSpace *space, cpConstraint *constraint);
    cpBool cpSpaceContainsShape(cpSpace *space, cpShape *shape);
    cpBool cpSpaceContainsBody(cpSpace *space, cpBody *body);
    cpBool cpSpaceContainsConstraint(cpSpace *space, cpConstraint *constraint);
    void cpSpaceAddPostStepCallback(cpSpace *space, cpPostStepFunc func, void *obj, void *data);
    void cpSpacePointQuery(cpSpace *space, cpVect point, cpLayers layers, cpGroup group, cpSpacePointQueryFunc func, void *data);
    cpShape *cpSpacePointQueryFirst(cpSpace *space, cpVect point, cpLayers layers, cpGroup group);
    void cpSpaceSegmentQuery(cpSpace *space, cpVect start, cpVect end, cpLayers layers, cpGroup group, cpSpaceSegmentQueryFunc func, void *data);
    cpShape *cpSpaceSegmentQueryFirst(cpSpace *space, cpVect start, cpVect end, cpLayers layers, cpGroup group, cpSegmentQueryInfo *out);
    void cpSpaceBBQuery(cpSpace *space, cpBB bb, cpLayers layers, cpGroup group, cpSpaceBBQueryFunc func, void *data);
    cpBool cpSpaceShapeQuery(cpSpace *space, cpShape *shape, cpSpaceShapeQueryFunc func, void *data);
    void cpSpaceActivateShapesTouchingShape(cpSpace *space, cpShape *shape);
    void cpSpaceEachBody(cpSpace *space, cpSpaceBodyIteratorFunc func, void *data);
    void cpSpaceEachShape(cpSpace *space, cpSpaceShapeIteratorFunc func, void *data);
    void cpSpaceEachConstraint(cpSpace *space, cpSpaceConstraintIteratorFunc func, void *data);
    void cpSpaceReindexStatic(cpSpace *space);
    void cpSpaceReindexShape(cpSpace *space, cpShape *shape);
    void cpSpaceReindexShapesForBody(cpSpace *space, cpBody *body);

    // cpBody.h
    struct cpBody {
    	cpBodyVelocityFunc velocity_func;
    	cpBodyPositionFunc position_func;
    	cpFloat m;
    	cpFloat m_inv;
    	cpFloat i;
    	cpFloat i_inv;
    	cpVect p;
    	cpVect v;
    	cpVect f;
    	cpFloat a;
    	cpFloat w;
    	cpFloat t;
    	cpVect rot;
    	cpDataPointer data;
    	cpFloat v_limit;
    	cpFloat w_limit;
    };
    cpBody *cpBodyAlloc(void);
    cpBody *cpBodyInit(cpBody *body, cpFloat m, cpFloat i);
    cpBody *cpBodyNew(cpFloat m, cpFloat i);
    cpBody *cpBodyInitStatic(cpBody *body);
    cpBody *cpBodyNewStatic();
    void cpBodyDestroy(cpBody *body);
    void cpBodyFree(cpBody *body);
    void cpBodyActivate(cpBody *body);
    void cpBodyActivateStatic(cpBody *body, cpShape *filter);
    void cpBodySleep(cpBody *body);
    void cpBodySleepWithGroup(cpBody *body, cpBody *group);
    static inline cpBool cpBodyIsSleeping(const cpBody *body);
    static inline cpBool cpBodyIsStatic(const cpBody *body);
    static inline cpBool cpBodyIsRogue(const cpBody *body);
    static inline cpVect cpBodyLocal2World(const cpBody *body, const cpVect v);
    static inline cpVect cpBodyWorld2Local(const cpBody *body, const cpVect v);
    void cpBodyResetForces(cpBody *body);
    void cpBodyApplyForce(cpBody *body, const cpVect f, const cpVect r);
    void cpBodyApplyImpulse(cpBody *body, const cpVect j, const cpVect r);
    static inline cpFloat cpBodyKineticEnergy(const cpBody *body);
    void cpBodyEachShape(cpBody *body, cpBodyShapeIteratorFunc func, void *data);
    void cpBodyEachConstraint(cpBody *body, cpBodyConstraintIteratorFunc func, void *data);
    void cpBodyEachArbiter(cpBody *body, cpBodyArbiterIteratorFunc func, void *data);
    
    // cpShape.h
    struct cpShape {
    	cpBody *body;
    	cpBB bb;
    	cpBool sensor;
    	cpFloat e;
    	cpFloat u;
    	cpVect surface_v;
    	cpDataPointer data;
    	cpCollisionType collision_type;
    	cpGroup group;
    	cpLayers layers;
    };
    void cpShapeDestroy(cpShape *shape);
    void cpShapeFree(cpShape *shape);
    cpBB cpShapeCacheBB(cpShape *shape);
    cpBB cpShapeUpdate(cpShape *shape, cpVect pos, cpVect rot);
    cpBool cpShapePointQuery(cpShape *shape, cpVect p);
    void cpResetShapeIdCounter(void);
    cpBool cpShapeSegmentQuery(cpShape *shape, cpVect a, cpVect b, cpSegmentQueryInfo *info);
    static inline cpVect cpSegmentQueryHitPoint(const cpVect start, const cpVect end, const cpSegmentQueryInfo info);
    static inline cpFloat cpSegmentQueryHitDist(const cpVect start, const cpVect end, const cpSegmentQueryInfo info);
    typedef struct cpCircleShape {
    	cpShape shape;
    	cpVect c, tc;
    	cpFloat r;
    } cpCircleShape;
    cpCircleShape *cpCircleShapeAlloc(void);
    cpCircleShape *cpCircleShapeInit(cpCircleShape *circle, cpBody *body, cpFloat radius, cpVect offset);
    cpShape *cpCircleShapeNew(cpBody *body, cpFloat radius, cpVect offset);
    typedef struct cpSegmentShape {
    	cpShape shape;
    	cpVect a, b, n;
    	cpVect ta, tb, tn;
    	cpFloat r;
    	cpVect a_tangent, b_tangent;
    } cpSegmentShape;
    cpSegmentShape* cpSegmentShapeAlloc(void);
    cpSegmentShape* cpSegmentShapeInit(cpSegmentShape *seg, cpBody *body, cpVect a, cpVect b, cpFloat radius);
    cpShape* cpSegmentShapeNew(cpBody *body, cpVect a, cpVect b, cpFloat radius);
    void cpSegmentShapeSetNeighbors(cpShape *shape, cpVect prev, cpVect next);
 
    // cpPolyShape.h
    cpShape *cpBoxShapeNew(cpBody *body, cpFloat width, cpFloat height);   
}